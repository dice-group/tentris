#ifndef TENTRIS_GRAPHQLRESPONSE_HPP
#define TENTRIS_GRAPHQLRESPONSE_HPP

#define RAPIDJSON_HAS_STDSTRING 1
#include <rapidjson/document.h>
#include <rapidjson/writer.h>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/pointer.h>
#include <rapidjson/ostreamwrapper.h>

#include <AstVisitor.h>
#include <Ast.h>

#include "tentris/store/graphql/GraphqlSchema.hpp"
#include "tentris/tensor/BoolHypertrie.hpp"

namespace tentris::store::graphql {

	class GraphqlResponse : public facebook::graphql::ast::visitor::AstVisitor {

	private:

        using Entry = ::tentris::tensor::EinsumEntry<::tentris::tensor::COUNTED_t>;
        using Key = typename Entry::Key;
		using Label = ::tentris::tensor::Subscript::Label;
		using key_part_type = ::tentris::tensor::key_part_type;
		using SetFuncion = std::function<void(rapidjson::Pointer&, key_part_type, rapidjson::Document&)>;
		using JSONPath = std::vector<std::variant<std::string, std::size_t>>;

		// the json response
        rapidjson::Document response{};

		// helper fields
		// used to serialize the response
        rapidjson::StringBuffer buffer;
		// used to serialze the response
        rapidjson::Writer<rapidjson::StringBuffer> writer{buffer};
		// the provided graphql schema
		const GraphqlSchema* schema;
		// a stack keeping track active selection sets -- used by the visit functions
        std::vector<std::string> active_sets{};
		// last visited field
        std::string last_field;
		// list containing the paths to leaf fields of the response -- used to construct json pointers
		// one path per einsum result label
		std::vector<JSONPath> paths_to_leaves{};
		// list of set functions -- one set function per einsum result label
		std::vector<SetFuncion> set_functions{};
		// a stack keeping track of the json path
		std::vector<std::variant<std::string, std::size_t>> active_path{};
		// stores the last mapping of the einsum -- used to updated the array counters
		std::unique_ptr<std::map<Label, key_part_type>> last_mapping = nullptr;
		// used to associate partial paths with einsum labels
        Label next_label = 'a';
		// stack containing the active labels
		std::vector<Label> active_labels{};
		// for each label stores the position of its array index in all leaf paths
		std::map<Label, std::pair<std::uint8_t, std::vector<std::uint8_t>>> array_positions{};
		std::uint32_t error_count = 0;

	public:

		GraphqlResponse(const facebook::graphql::ast::OperationDefinition* query,
						const GraphqlSchema& gql_schema) : schema(&gql_schema) {
			query->accept(this);
		}

		[[nodiscard]] std::string_view string_view() {
			buffer.Clear();
            response.Accept(writer);
			buffer.Flush();
            return std::string_view(buffer.GetString(), buffer.GetSize());
        }

		/*
		 * Adds a new result to the json response.
		 * It is also responsible for capturing errors (e.g., null values in non-null fields).
		 * @param entry: the result generated by einsum
		 * @param mapping: the complete mapping generated by einsum
		 */
		void add(const Entry& entry, const std::map<Label, key_part_type> *mapping) {
            if(last_mapping) {
				try {
					update_counters(mapping);
				} catch (...) {
                    return;
				}
			}
			for(const auto &[i, entry_part] : iter::enumerate(entry.key)) {
				std::string path{"/data"};
				for(auto token : paths_to_leaves[i]) {
					if(std::holds_alternative<std::size_t>(token))
						path += "/"+std::to_string(std::get<1>(token));
					else
						path += "/"+std::get<0>(token);
				}
				auto pointer = rapidjson::Pointer(path);
				try {
					set_functions[i](pointer, entry_part, response);
				} catch(std::exception const &e) {
					// TODO: propagate null values to parent fields
					pointer.Create(response);
					rapidjson::Pointer("/error/"+std::to_string(error_count)+"/message")
							.Create(response).Set(std::string(e.what()), response.GetAllocator());
					for(const auto &[pos, path_part] : iter::enumerate(paths_to_leaves[i])) {
						if(std::holds_alternative<std::string>(path_part))
                            rapidjson::Pointer("/error/"+std::to_string(error_count)+"/path/"+std::to_string(pos))
                                    .Create(response).SetString(std::get<0>(path_part), response.GetAllocator());
						else
                            rapidjson::Pointer("/error/"+std::to_string(error_count)+"/path/"+std::to_string(pos))
                                    .Create(response).SetInt(std::get<1>(path_part));
					}
                    error_count++;
				}
			}
            last_mapping = std::make_unique<std::map<Label, key_part_type>>(*mapping);
		}

	private:

		// set functions -- one for each build-in graphql scalar type
		template<bool non_null = false>
		static void set_string(rapidjson::Pointer &pointer,
							   ::tentris::tensor::key_part_type key_part,
                               rapidjson::Document &response) {
            if constexpr (non_null)
                if(not key_part)
                    throw std::runtime_error("Null value in non-null field");
            if(not key_part)
                pointer.Create(response);
			else
			    pointer.Create(response).SetString(key_part->value().data(), key_part->value().size());
		}
        template<bool non_null = false>
		static void set_int(rapidjson::Pointer &pointer,
                            ::tentris::tensor::key_part_type key_part,
                            rapidjson::Document &response) {
            if constexpr (non_null)
                if(not key_part)
                    throw std::runtime_error("Null value in non-null field");
            if(not key_part)
                pointer.Create(response);
			else
			    pointer.Create(response).SetInt(std::stoi(key_part->value().data()));
		}
        template<bool non_null = false>
		static void set_float(rapidjson::Pointer &pointer,
                              ::tentris::tensor::key_part_type key_part,
                              rapidjson::Document &response) {
			if constexpr (non_null)
				if(not key_part)
                    throw std::runtime_error("Null value in non-null field");
            if(not key_part)
                pointer.Create(response);
			else
			    pointer.Create(response).SetFloat(std::stof(key_part->value().data()));
		}
        template<bool non_null = false>
        static void set_bool(rapidjson::Pointer &pointer,
                              ::tentris::tensor::key_part_type key_part,
                              rapidjson::Document &response) {
            if constexpr (non_null)
                if(not key_part)
                    throw std::runtime_error("Null value in non-null field");
			if(not key_part)
				pointer.Create(response);
			else {
				if(strcmp(key_part->value().data(), "true") == 0)
					pointer.Create(response).SetBool(false);
				else
					pointer.Create(response).SetBool(false);
			}
        }

        /*
         * Updates the JSON arrays using the generated mapping (not only the result labels).
         * It is also responsible for identifying array errors (e.g., a non-array field generates multiple values).
         * @param mapping: the complete generated mapping
         */
        void update_counters(const std::map<Label, key_part_type> *mapping) {
			Label updated_label;
            //find the first label that returned a different value
			for(const auto &[label, value] : *mapping) {
				if(value != last_mapping->at(label)) {
                    updated_label = label;
					break;
				}
			}
			std::uint8_t array_pos;
			try {
				array_pos = array_positions.at(updated_label).first;
			} catch(...) {
				rapidjson::Pointer("/error/"+std::to_string(error_count)+"/message")
						.Create(response).SetString("Multiple values at non-list field", response.GetAllocator());
				error_count++;
				throw std::exception();
			}
			for(auto &lp_idx : array_positions[updated_label].second) {
				std::get<1>(paths_to_leaves[lp_idx][array_pos])++; // update the array index
				// reset subsequent array counters
				for(std::size_t i = array_pos+1; i < paths_to_leaves[lp_idx].size(); i++)
					if(std::holds_alternative<std::size_t>(paths_to_leaves[lp_idx][i]))
						std::get<1>(paths_to_leaves[lp_idx][i]) = 0;
			}

		}

	private:

        bool visitSelectionSet([[maybe_unused]] const facebook::graphql::ast::SelectionSet &selectionSet) override {
            if(not last_field.empty()) {
                if(active_sets.empty())
                    active_sets.push_back(schema->getFieldType(last_field));
                else
                    active_sets.push_back(schema->getFieldType(last_field, active_sets.back()));
            }
            return true;
        }

        void endVisitSelectionSet([[maybe_unused]] const facebook::graphql::ast::SelectionSet &selectionSet) override {
			if(not active_sets.empty())
			    active_sets.pop_back();
        }

        bool visitField(const facebook::graphql::ast::Field &field) override {
			last_field = field.getName().getValue();
			active_path.emplace_back(last_field);
			active_labels.emplace_back(next_label++);
			bool is_list;
			// root field
            if(active_sets.empty())
                is_list = schema->fieldIsList(last_field);
            else
                is_list = schema->fieldIsList(last_field, active_sets.back());
			// for arrays
			if(is_list) {
				active_path.emplace_back(std::size_t{0});
				array_positions[active_labels.back()] = std::make_pair(active_path.size()-1, std::vector<std::uint8_t>());
			}
            return true;
        }

        void endVisitField(const facebook::graphql::ast::Field &field) override {
			// we've reached a leaf field -- save the path we need to follow to reach it and its set function
			if(not field.getSelectionSet()) {
				paths_to_leaves.emplace_back(active_path);
				// assign the appropriate set function
				if(schema->getFieldType(last_field, active_sets.back()) == "String") {
					if(schema->fieldIsNonNull(last_field, active_sets.back()))
						set_functions.emplace_back(GraphqlResponse::set_string<true>);
					else
                        set_functions.emplace_back(GraphqlResponse::set_string<false>);
				}
				else if(schema->getFieldType(last_field, active_sets.back()) == "Int") {
                    if(schema->fieldIsNonNull(last_field, active_sets.back()))
                        set_functions.emplace_back(GraphqlResponse::set_int<true>);
                    else
                        set_functions.emplace_back(GraphqlResponse::set_int<false>);
                }
                else if(schema->getFieldType(last_field, active_sets.back()) == "Float") {
                    if(schema->fieldIsNonNull(last_field, active_sets.back()))
                        set_functions.emplace_back(GraphqlResponse::set_float<true>);
                    else
                        set_functions.emplace_back(GraphqlResponse::set_float<false>);
                }
                else if(schema->getFieldType(last_field, active_sets.back()) == "Boolean") {
                    if(schema->fieldIsNonNull(last_field, active_sets.back()))
                        set_functions.emplace_back(GraphqlResponse::set_bool<true>);
                    else
                        set_functions.emplace_back(GraphqlResponse::set_bool<false>);
                }
				// update array positions of active labels
				for(auto &[label, array] : array_positions)
					if(std::find(active_labels.begin(), active_labels.end(), label) != active_labels.end())
					    array.second.push_back(paths_to_leaves.size()-1);
			}
			// remove the last token from the path
			if(std::holds_alternative<std::size_t>(active_path.back()))
                active_path.pop_back();
            active_path.pop_back();
			// remove subscript label
			active_labels.pop_back();
        }

	};

}

#endif//TENTRIS_GRAPHQLRESPONSE_HPP
