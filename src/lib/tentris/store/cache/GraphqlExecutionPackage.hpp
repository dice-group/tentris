#ifndef TENTRIS_GRAPHQLEXECUTIONPACKAGE_HPP
#define TENTRIS_GRAPHQLEXECUTIONPACKAGE_HPP

#include <any>
#include <exception>
#include <ostream>

#include "tentris/store/AtomicTripleStore.hpp"
#include "tentris/store/graphql/ParsedGraphql.hpp"
#include "tentris/store/graphql/GraphqlSchema.hpp"
#include "tentris/tensor/BoolHypertrie.hpp"

namespace tentris::store {
    class TripleStore;
};

namespace tentris::store::cache {

	/**
     * A QueryExecutionPackage contains everything that is necessary to execute a given graphql query for a state of the
     * RDF graph.
     */
	struct GraphqlExecutionPackage {

		using const_BoolHypertrie = ::tentris::tensor::const_BoolHypertrie;
		using time_point_t = logging::time_point_t;
		using ParsedGraphql = graphql::ParsedGraphql;
        using GraphqlSchema = graphql::GraphqlSchema;
		using Subscript = ::tentris::tensor::Subscript;
		using EinsumCounted = ::tentris::tensor::Einsum<::tentris::tensor::COUNTED_t>;


	private:

		std::string query_name;
		// a graphql query can generate multiple subscripts (multiple root fields)
		std::vector<std::shared_ptr<Subscript>> subscripts;
		// a vector containing the operands of each subscript
        std::vector<std::vector<const_BoolHypertrie>> operands{};

	public:

		GraphqlExecutionPackage() = delete;

		/**
         * @param graphql_string graphql query to be parsed
         */
		explicit GraphqlExecutionPackage(const std::string& request_doc_path,
										 const GraphqlSchema &schema,
										 const std::string& query_name = "") : query_name(query_name) {
            using namespace logging;
            ParsedGraphql parsed_graphql;
            logDebug(fmt::format("Parsing query: {}", query_name));
			if(query_name.empty())
				parsed_graphql = ParsedGraphql{request_doc_path, schema};
			else
				parsed_graphql = ParsedGraphql{request_doc_path, query_name, schema};
            subscripts = parsed_graphql.getSubscripts();
            logDebug(fmt::format("Parsed subscripts: {}", subscripts));
            auto &triple_store = AtomicTripleStore::getInstance();
            logDebug(fmt::format("Slicing TPs"));
			// iterate of the slice keys generated by the parsing of the graphql query
            // one set of slice keys for each subscript (i.e., root query field)
            for(auto &gql_root_field_slice_keys : parsed_graphql.getSliceKeys()) {
				std::vector<const_BoolHypertrie> root_field_operands{};
				// special treatment of the root field
				auto& root_field_slice_key = gql_root_field_slice_keys[0];
				// root field is leaf field as well
				if(gql_root_field_slice_keys.size() > 1)
                    root_field_operands.push_back(triple_store.resolveGQLRootField(root_field_slice_key));
				else
                    root_field_operands.push_back(triple_store.resolveGQLField(root_field_slice_key));
				for(auto iter = gql_root_field_slice_keys.begin()+1; iter != gql_root_field_slice_keys.end(); iter++)
                    root_field_operands.push_back(triple_store.resolveGQLField(*iter));
                operands.emplace_back(std::move(root_field_operands));
            }
		}

		[[nodiscard]] std::unique_ptr<std::vector<std::shared_ptr<EinsumCounted>>>&& generateEinsums(const time_point_t &timeout) {
            std::unique_ptr<std::vector<std::shared_ptr<EinsumCounted>>> einsums{};
			for(auto i : iter::range(subscripts.size())) {
				einsums->push_back(std::make_shared<EinsumCounted>(subscripts[i], operands[i], timeout));
			}
			return std::move(einsums);
		}

		[[nodiscard]] const std::vector<std::shared_ptr<Subscript>> &getSubscripts() const {
			return subscripts;
		}

		[[nodiscard]] const std::vector<std::vector<const_BoolHypertrie>> &getOperands() const {
			return operands;
		}

		friend struct ::fmt::formatter<GraphqlExecutionPackage>;

	};

}

template<>
struct fmt::formatter<tentris::store::cache::GraphqlExecutionPackage> {
    template<typename ParseContext>
    constexpr auto parse(ParseContext &ctx) { return ctx.begin(); }

    template<typename FormatContext>
    auto format(const tentris::store::cache::GraphqlExecutionPackage &p, FormatContext &ctx) {
        return format_to(ctx.begin(),
                         " GraphQL Query Name:     {}\n"
                         " subscripts:  {}\n",
                         p.query_name, p.subscripts);
    }
};
#endif//TENTRIS_GRAPHQLEXECUTIONPACKAGE_HPP
